"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import ForceGraph2D from "react-force-graph-2d";

type GraphJSON = {
  nodes: { id: string; label: string; slug?: string; courseId?: number }[];
  edges: { id: string; source: string; target: string }[];
  meta?: any;
};

type Manifest = {
  version: number;
  courses: { id: number; slug: string; title: string; size: number; x: number; y: number; r: number }[];
  cross: { from: number; to: number; count: number }[];
};

export default function WowGraph({ src = "/graph/v1/graph.json" }: { src?: string }) {
  // Always render the full graph (no sharding) so all dots are visible ("open").
  return <WowFullGraph src={src}/>;
}

function WowFullGraph({ src }: { src: string }) {
  const [data, setData] = useState<GraphJSON | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const ref = useRef<any>(null);
  const [focus, setFocus] = useState<string | null>(null);
  const [hover, setHover] = useState<any | null>(null);
  const [, setFrame] = useState(0);
  const mouse = useRef<{x:number;y:number}>({x:0,y:0});
  const tRef = useRef(0);

  // Load static data
  useEffect(() => {
    let cancelled = false;
    fetch(src)
      .then(r => r.json())
      .then(j => { if (!cancelled) setData(j); })
      .catch(e => { if (!cancelled) setErr(String(e)); });
    return () => { cancelled = true; };
  }, [src]);

  // Dev augmentation: if dataset small, synthesize ~100 lessons to play with
  const augmented = useMemo<GraphJSON | null>(() => {
    if (!data) return null;
    const DEV = typeof window !== 'undefined' && (new URLSearchParams(window.location.search).has('dev') || process.env.NODE_ENV !== 'production');
    if (!DEV) return data;
    if (data.nodes.length >= 50) return data;
    // Deterministic pseudo-random for stable builds
    let seed = 42; const rand = () => (seed = (seed * 1664525 + 1013904223) % 4294967296) / 4294967296;
    const nodes = data.nodes.slice();
    const edges = data.edges.slice();
    const startId = nodes.length ? Math.max(...nodes.map(n => Number(n.id) || 0)) + 1 : 1;
    const targetCount = 50; // total nodes including originals
    const courseCount = 5;
    const cats = ['anatomy','physiology','biochem','path','pharm'];
    for (let i = startId; i < targetCount + 1; i++) {
      nodes.push({ id: String(i), label: `Lesson ${i}` as any, courseId: 1 + Math.floor(rand() * courseCount), category: cats[Math.floor(rand()*cats.length)] } as any);
      // add 1-3 prerequisites among previous 20 nodes to ensure DAG
      const prereqCandidates = [] as number[];
      for (let k = Math.max(1, i - 20); k < i; k++) prereqCandidates.push(k);
      const prereqNum = 1 + Math.floor(rand() * 3);
      for (let t = 0; t < prereqNum && prereqCandidates.length; t++) {
        const j = Math.floor(rand() * prereqCandidates.length);
        const src = prereqCandidates.splice(j, 1)[0];
        edges.push({ id: `e${src}-${i}-${t}` as any, source: String(src), target: String(i) });
      }
    }
    // Ensure single connected component (ignore direction for connectivity)
    const idSet = new Set(nodes.map(n => String(n.id)));
    const undirected = new Map<string, Set<string>>();
    const addUndirected = (a:string,b:string) => {
      if (!undirected.has(a)) undirected.set(a, new Set());
      if (!undirected.has(b)) undirected.set(b, new Set());
      undirected.get(a)!.add(b); undirected.get(b)!.add(a);
    };
    for (const id of idSet) addUndirected(id, id); // init
    for (const e of edges) addUndirected(String((e as any).source), String((e as any).target));
    const all = Array.from(idSet);
    if (all.length) {
      const visited = new Set<string>();
      const q=[all[0]]; visited.add(all[0]);
      while(q.length){ const v=q.shift()!; const nbrs=undirected.get(v) || new Set(); for(const u of nbrs){ if(!visited.has(u)){ visited.add(u); q.push(u); } } }
      let bridgeIdx = 0;
      for (const id of all) {
        if (!visited.has(id)) {
          // connect this orphan to some visited node
          const target = all[bridgeIdx % visited.size];
          edges.push({ id: `b${id}-${target}`, source: target, target: id } as any);
          addUndirected(target, id);
          visited.add(id);
          bridgeIdx++;
        }
      }
    }
    return { ...data, nodes, edges };
  }, [data]);

  // Build runtime graph data for force-graph (objects are mutated by the lib)
  const fgData = useMemo(() => {
    if (!augmented) return null as any;
    // Randomly mark ~35% as completed for demo
    let seed = 7; const rand = () => (seed = (seed * 1103515245 + 12345) % 4294967296) / 4294967296;
    const nodes = augmented.nodes.map((n: any) => ({
      id: n.id,
      name: n.label,
      courseId: n.courseId,
      completed: rand() < 0.35,
      href: n.href || (n.slug ? `/lesson/${n.slug}` : undefined),
      lengthMin: n.lengthMin,
      excerpt: n.excerpt,
      courseSlug: n.courseSlug,
      courseTitle: n.courseTitle,
      slug: n.slug,
      category: n.category,
    }));
    const links = augmented.edges.map(e => ({ id: e.id, source: e.source, target: e.target }));
    return { nodes, links } as any;
  }, [augmented]);

  // Precompute incoming adjacency for fast ancestor traversal
  const inMap = useMemo(() => {
    if (!augmented) return null as Map<string, string[]> | null;
    const m = new Map<string, string[]>();
    for (const e of augmented.edges) {
      const tgt = String(e.target);
      const src = String(e.source);
      const arr = m.get(tgt) || [];
      arr.push(src);
      m.set(tgt, arr);
    }
    return m;
  }, [augmented]);

  // Highlight computation
  useEffect(() => {
    if (!fgData || !inMap) return;
    const nodes = fgData.nodes as any[];
    const links = fgData.links as any[];
    // reset
    nodes.forEach(n => { n.__on = false; });
    links.forEach(l => { l.__on = false; l.__tier = undefined; });
    if (!focus) return;
    // BFS on reversed edges: compute depth to focus
    const depth = new Map<string, number>();
    const q: string[] = [focus];
    depth.set(focus, 0);
    while (q.length) {
      const t = q.shift()!;
      const d = depth.get(t)!;
      const parents = inMap.get(t) || [];
      for (const p of parents) if (!depth.has(p)) { depth.set(p, d + 1); q.push(p); }
    }
    // mark nodes
    nodes.forEach(n => { if (depth.has(String(n.id))) n.__on = true; });
    // mark edges on path: parent -> child where depth[parent] = depth[child]+1
    links.forEach(l => {
      const s = String((l.source as any)?.id ?? (l as any).source);
      const t = String((l.target as any)?.id ?? (l as any).target);
      const ds = depth.get(s); const dt = depth.get(t);
      (l as any).__tier = dt;
      if (ds !== undefined && dt !== undefined && ds === dt + 1) l.__on = true; else l.__on = false;
    });

    // Emit a wave of particles along the whole chain tier-by-tier so long paths animate
    const maxTier = Math.max(...Array.from(depth.values()));
    let step = 0;
    const tick = () => {
      if (!ref.current) return;
      for (const l of links as any[]) {
        if (!l.__on) continue;
        if ((l.__tier ?? 0) === step) {
          try {
            ref.current.emitParticle(l);
            ref.current.emitParticle(l);
            ref.current.emitParticle(l);
          } catch {}
        }
      }
      step = (step + 1) % Math.max(1, maxTier + 1);
    };
    const id = window.setInterval(tick, 250);
    return () => window.clearInterval(id);
  }, [focus, fgData, inMap]);

  // Camera fit on first render
  useEffect(() => {
    if (!ref.current || !fgData) return;
    const t = setTimeout(() => {
      try {
        if (typeof (ref.current as any).zoomToFit === "function") {
          (ref.current as any).zoomToFit(400, 50);
        }
      } catch {}
    }, 0);
    return () => clearTimeout(t);
  }, [fgData]);

  // Continuous rope animation (trigger canvas redraw via React re-render)
  useEffect(() => {
