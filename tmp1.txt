"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { motion } from "framer-motion";
import { useSession } from "next-auth/react";
import VideoPanel from "@/components/lesson/VideoPanel";
import LessonBody from "@/components/lesson/LessonBody";
import UniResources from "@/components/lesson/UniResources";
import AnkiDownload from "@/components/lesson/AnkiDownload";
import ConceptChecklist from "@/components/lesson/ConceptChecklist";
import BackgroundMap from "@/components/lesson/BackgroundMap";
import Glossary from "@/components/lesson/Glossary";
import StudyToolbar from "@/components/lesson/StudyToolbar";

type Block = { id: number; kind: string; content: string };
type Lesson = { id: number; slug: string; title: string };
type Course = { id: number; slug: string; title: string } | null;
type Chapter = { id: number; slug: string; title: string; description?: string | null; position?: number; meta?: any } | null;

type CourseProg = { total: number; completed: number; pct: number } | null;

type LessonProg = { completed: boolean; qTotal: number; qCorrect: number; lessonPct: number } | null;

type NavInfo = { prev: { slug: string; title: string } | null; next: { slug: string; title: string } | null } | null;

type Timeline = { lessons: { id: number; slug: string; title: string; completed?: boolean; qCount?: number }[] } | null;

export default function LessonPage() {
  const { status } = useSession();
  const isAuthed = status === "authenticated";
  const { slug: rawSlug } = useParams();
  const slug = String(rawSlug || "");

  const [lesson, setLesson] = useState<Lesson | null>(null);
  const [blocks, setBlocks] = useState<Block[]>([]);
  const [tab, setTab] = useState<"learn" | "practice">("learn");
  const [qs, setQs] = useState<any[]>([]);
  const [ansState, setAnsState] = useState<Record<number, "correct" | "wrong">>({});
  const [idx, setIdx] = useState(0);
  const [picked, setPicked] = useState<number | null>(null);
  const [isComplete, setIsComplete] = useState(false);
  const [isSavingComplete, setIsSavingComplete] = useState(false);
  const completeBtnRef = useRef<HTMLButtonElement | null>(null);

  const [nav, setNav] = useState<NavInfo>(null);
  const [course, setCourse] = useState<Course>(null);
  const [chapter, setChapter] = useState<Chapter>(null);
  const [courseProg, setCourseProg] = useState<CourseProg>(null);
  const [lessonProg, setLessonProg] = useState<LessonProg>(null);
  const [timeline, setTimeline] = useState<Timeline>(null);
  const [uniSynced, setUniSynced] = useState<boolean>(false);
  const [unlockDemoVideo, setUnlockDemoVideo] = useState<boolean>(false);
  const [focusMode, setFocusMode] = useState<boolean>(false);
  const [introVisited, setIntroVisited] = useState<boolean>(false);
  const [nudgeDismissed, setNudgeDismissed] = useState<boolean>(false);
  const [player, setPlayer] = useState<{ provider: string | null; iframeSrc: string | null; locked?: boolean; lockReason?: string; source?: "video_html" | "body" | "none" } | null>(null);

  const q = qs[idx];

  // URL router + search params
  const searchParams = useSearchParams();
  const router = useRouter();

  // Initialize tab and question index from URL on slug change
  useEffect(() => {
    const t = (searchParams.get('tab') || '').toLowerCase();
    if (t === 'learn' || t === 'practice') setTab(t as any);
    const qParam = Number(searchParams.get('q') || NaN);
    if (Number.isFinite(qParam) && qParam > 0) setIdx(Math.max(0, qParam - 1));
    try {
      const u = searchParams.get('uni');
      const saved = typeof window !== 'undefined' ? window.localStorage.getItem('ems:uniSynced') : null;
      setUniSynced(u === '1' || saved === '1');
      setUnlockDemoVideo((searchParams.get('demo') || '') === '1');
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [slug]);

  // Load lesson and course/timeline data
  useEffect(() => {
    (async () => {
      const res = await fetch(`/api/lesson/${slug}`);
      if (!res.ok) {
        // Reset to safe defaults when lesson is missing
        setLesson(null);
        setBlocks([]);
        setNav(null);
        setCourse(null);
        setChapter(null);
        setCourseProg(null);
        setTimeline(null);
        return;
      }
      const j = await res.json();
      setLesson(j?.lesson ?? null);
      setBlocks(Array.isArray(j?.blocks) ? j.blocks : []);
      setNav(j?.nav || null);
      setCourse(j?.course || null);
      setChapter(j?.chapter || null);
      setCourseProg(j?.courseProgress || null);
      setTimeline(j?.timeline || null);
    })();
  }, [slug]);

  // Load player embed (lazy, small payload) â€” avoids fetching large bodies repeatedly
  useEffect(() => {
    (async () => {
      try {
        const qs = unlockDemoVideo ? "?demo=1" : "";
        const r = await fetch(`/api/lesson/${slug}/player${qs}`);
        if (!r.ok) { setPlayer(null); return; }
        const k = await r.json();
        setPlayer(k || null);
      } catch { setPlayer(null); }
    })();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [slug, unlockDemoVideo]);

  // Load questions on opening practice
  useEffect(() => {
    if (tab !== "practice") return;
    (async () => {
      const r = await fetch(`/api/lesson/${slug}/questions`);
      const j = await r.json();
      setQs(j.questions || []);
      const qParam = Number(searchParams.get('q') || NaN);
      const startIdx = (Number.isFinite(qParam) && qParam > 0) ? Math.max(0, Math.min((j.questions?.length || 1) - 1, qParam - 1)) : 0;
      setIdx(startIdx);
      setPicked(null);
      const init: Record<number, "correct" | "wrong"> = {};
      (j.questions || []).forEach((qq: any) => {
        if (qq.answeredCorrect) init[Number(qq.id)] = "correct";
        else if (qq.selectedChoiceId != null) init[Number(qq.id)] = "wrong";
      });
      setAnsState(init);
    })();
  }, [slug, tab]);

  // Track lightweight progress (only when authenticated)
  useEffect(() => {
    if (!isAuthed) return;
    fetch(`/api/lesson/${slug}/progress`, {
      method: "POST",
      body: JSON.stringify({ progress: tab === "learn" ? 40 : 70 }),
      headers: { "Content-Type": "application/json" },
      credentials: "include",
    });
  }, [slug, tab, isAuthed]);

  // Load completion status and per-lesson progress
  useEffect(() => {
    (async () => {
      if (!isAuthed) {
        setIsComplete(false);
        setLessonProg(null);
        return;
      }
      try {
        const r = await fetch(`/api/lesson/${slug}/progress`, { credentials: "include" });
        const j = await r.json();
        setIsComplete(!!j.completed);
        if (j && ("lessonPct" in j)) setLessonProg(j);
      } catch {}
    })();
  }, [slug, isAuthed]);

  // Read intro visited + nudge state when chapter changes
  useEffect(() => {
    if (!chapter?.slug) { setIntroVisited(false); return; }
    try {
      const visited = localStorage.getItem(`ems:chapter:intro:visited:${chapter.slug}`) === '1';
      setIntroVisited(visited);
      setNudgeDismissed(localStorage.getItem(`ems:chapter:intro:nudge:${chapter.slug}:dismissed`) === '1');
    } catch {}
  }, [chapter?.slug]);

  const progressPct = useMemo(() => (qs.length ? Math.round((idx) / qs.length * 100) : 0), [idx, qs.length]);

  // Keep URL in sync with tab and question index for shareable deep links
  useEffect(() => {
    const params = new URLSearchParams(searchParams.toString());
    params.set('tab', tab);
    if (tab === 'practice') params.set('q', String(Math.max(1, Math.min(qs.length || 1, idx + 1))));
    else params.delete('q');
    router.replace(`/lesson/${slug}?${params.toString()}`);
  }, [tab, idx, qs.length, slug]);

  async function markCompleteToggle() {
    if (!isAuthed) return;
    const target = !isComplete;
    const wasComplete = isComplete;
    setIsSavingComplete(true);
    setIsComplete(target);
    setTimeline((tl) => (tl ? { lessons: tl.lessons.map((l) => (l.slug === slug ? { ...l, completed: target } : l)) } : tl));
    setCourseProg((p) => {
      if (!p) return p;
      if (wasComplete === target) return p;
      const completed = Math.max(0, Math.min(p.total, p.completed + (target ? 1 : -1)));
      const pct = p.total ? Math.round((completed / p.total) * 100) : 0;
      return { ...p, completed, pct } as any;
    });
    try {
      const res = await fetch(`/api/lesson/${slug}/progress`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ completed: target }),
      });
        if (res.ok) {
          const payload = await res.json().catch(() => ({}));
          if (payload?.capReached === true) {
            try { localStorage.setItem(`xpCap:lesson:${new Date().toISOString().slice(0,10)}`, '1'); } catch {}
            try { window.dispatchEvent(new CustomEvent('xp:cap' as any, { detail: { source: 'lesson' } })); } catch {}
          } else if (payload?.awardedXp && Number(payload.awardedXp) > 0) {
            const rect = completeBtnRef.current?.getBoundingClientRect();
            const from = rect ? { x: rect.left + rect.width / 2, y: rect.top } : { x: window.innerWidth - 80, y: 12 };
            window.dispatchEvent(new CustomEvent("xp:awarded", { detail: { amount: Number(payload.awardedXp), from, newLevel: Number(payload.newLevel || 1), newPct: Number(payload.pct || 0), newInLevel: Number(payload.inLevel || 0), newSpan: Number(payload.span || 1) } }));
          }
        if (Array.isArray((payload as any)?.rewards)) {
          for (const r of (payload as any).rewards) {
            try { window.dispatchEvent(new CustomEvent('reward:earned', { detail: r })); } catch {}
            try { if (r?.type === 'chest' && typeof r?.key === 'string') localStorage.setItem(`ems:chest:flash:${r.key}`, '1'); } catch {}
          }
        }
      } else {
        // revert
        setIsComplete(!target);
        setTimeline((tl) => (tl ? { lessons: tl.lessons.map((l) => (l.slug === slug ? { ...l, completed: wasComplete } : l)) } : tl));
        setCourseProg((p) => {
          if (!p) return p;
          if (wasComplete === target) return p;
          const completed = Math.max(0, Math.min(p.total, p.completed + (target ? -1 : 1)));
          const pct = p.total ? Math.round((completed / p.total) * 100) : 0;
          return { ...p, completed, pct } as any;
        });
      }
    } finally {
      setIsSavingComplete(false);
    }
  }

  function next() {
    if (idx < qs.length - 1) {
      setIdx(idx + 1);
      setPicked(null);
    } else {
